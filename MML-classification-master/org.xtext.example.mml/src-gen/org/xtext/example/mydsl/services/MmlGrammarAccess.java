/*
 * generated by Xtext 2.20.0
 */
package org.xtext.example.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MmlGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MMLModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MMLModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cInputAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cInputDataInputParserRuleCall_0_0 = (RuleCall)cInputAssignment_0.eContents().get(0);
		private final Assignment cAlgorithmsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAlgorithmsMLChoiceAlgorithmParserRuleCall_1_0 = (RuleCall)cAlgorithmsAssignment_1.eContents().get(0);
		private final Assignment cFormulaAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFormulaRFormulaParserRuleCall_2_0 = (RuleCall)cFormulaAssignment_2.eContents().get(0);
		private final Assignment cValidationAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValidationValidationParserRuleCall_3_0 = (RuleCall)cValidationAssignment_3.eContents().get(0);
		
		//MMLModel:
		//	input=DataInput
		//	algorithms+=MLChoiceAlgorithm+
		//	formula=RFormula?
		//	validation=Validation;
		@Override public ParserRule getRule() { return rule; }
		
		//input=DataInput algorithms+=MLChoiceAlgorithm+ formula=RFormula? validation=Validation
		public Group getGroup() { return cGroup; }
		
		//input=DataInput
		public Assignment getInputAssignment_0() { return cInputAssignment_0; }
		
		//DataInput
		public RuleCall getInputDataInputParserRuleCall_0_0() { return cInputDataInputParserRuleCall_0_0; }
		
		//algorithms+=MLChoiceAlgorithm+
		public Assignment getAlgorithmsAssignment_1() { return cAlgorithmsAssignment_1; }
		
		//MLChoiceAlgorithm
		public RuleCall getAlgorithmsMLChoiceAlgorithmParserRuleCall_1_0() { return cAlgorithmsMLChoiceAlgorithmParserRuleCall_1_0; }
		
		//formula=RFormula?
		public Assignment getFormulaAssignment_2() { return cFormulaAssignment_2; }
		
		//RFormula
		public RuleCall getFormulaRFormulaParserRuleCall_2_0() { return cFormulaRFormulaParserRuleCall_2_0; }
		
		//validation=Validation
		public Assignment getValidationAssignment_3() { return cValidationAssignment_3; }
		
		//Validation
		public RuleCall getValidationValidationParserRuleCall_3_0() { return cValidationValidationParserRuleCall_3_0; }
	}
	public class DataInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DataInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatainputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilelocationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilelocationSTRINGTerminalRuleCall_1_0 = (RuleCall)cFilelocationAssignment_1.eContents().get(0);
		private final Assignment cParsingInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0 = (RuleCall)cParsingInstructionAssignment_2.eContents().get(0);
		
		///*
		// * 
		// * mini DSL to read data (here CSV)
		// * mini CSV DSL
		// */ DataInput:
		//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
		@Override public ParserRule getRule() { return rule; }
		
		//'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?
		public Group getGroup() { return cGroup; }
		
		//'datainput'
		public Keyword getDatainputKeyword_0() { return cDatainputKeyword_0; }
		
		//filelocation=STRING
		public Assignment getFilelocationAssignment_1() { return cFilelocationAssignment_1; }
		
		//STRING
		public RuleCall getFilelocationSTRINGTerminalRuleCall_1_0() { return cFilelocationSTRINGTerminalRuleCall_1_0; }
		
		//parsingInstruction=CSVParsingConfiguration?
		public Assignment getParsingInstructionAssignment_2() { return cParsingInstructionAssignment_2; }
		
		//CSVParsingConfiguration
		public RuleCall getParsingInstructionCSVParsingConfigurationParserRuleCall_2_0() { return cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0; }
	}
	public class CSVParsingConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVParsingConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeparatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSepCSVSeparatorEnumRuleCall_1_0 = (RuleCall)cSepAssignment_1.eContents().get(0);
		
		//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//	"separator" sep=CSVSeparator;
		@Override public ParserRule getRule() { return rule; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator" sep=CSVSeparator
		public Group getGroup() { return cGroup; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator"
		public Keyword getSeparatorKeyword_0() { return cSeparatorKeyword_0; }
		
		//sep=CSVSeparator
		public Assignment getSepAssignment_1() { return cSepAssignment_1; }
		
		//CSVSeparator
		public RuleCall getSepCSVSeparatorEnumRuleCall_1_0() { return cSepCSVSeparatorEnumRuleCall_1_0; }
	}
	public class MLChoiceAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLChoiceAlgorithm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMlframeworkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFrameworkAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFrameworkFrameworkLangEnumRuleCall_1_0 = (RuleCall)cFrameworkAssignment_1.eContents().get(0);
		private final Keyword cAlgorithmKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAlgorithmAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAlgorithmMLAlgorithmParserRuleCall_3_0 = (RuleCall)cAlgorithmAssignment_3.eContents().get(0);
		
		///*
		// * mini DSL to select the ML algorithm we want 
		// * we include the choice of the targeted language/framework
		// * ML algorithms can have hyperparameters
		// * 
		// */ MLChoiceAlgorithm:
		//	'mlframework' framework=FrameworkLang
		//	'algorithm' algorithm=MLAlgorithm;
		@Override public ParserRule getRule() { return rule; }
		
		//'mlframework' framework=FrameworkLang 'algorithm' algorithm=MLAlgorithm
		public Group getGroup() { return cGroup; }
		
		//'mlframework'
		public Keyword getMlframeworkKeyword_0() { return cMlframeworkKeyword_0; }
		
		//framework=FrameworkLang
		public Assignment getFrameworkAssignment_1() { return cFrameworkAssignment_1; }
		
		//FrameworkLang
		public RuleCall getFrameworkFrameworkLangEnumRuleCall_1_0() { return cFrameworkFrameworkLangEnumRuleCall_1_0; }
		
		//'algorithm'
		public Keyword getAlgorithmKeyword_2() { return cAlgorithmKeyword_2; }
		
		//algorithm=MLAlgorithm
		public Assignment getAlgorithmAssignment_3() { return cAlgorithmAssignment_3; }
		
		//MLAlgorithm
		public RuleCall getAlgorithmMLAlgorithmParserRuleCall_3_0() { return cAlgorithmMLAlgorithmParserRuleCall_3_0; }
	}
	public class MLAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLAlgorithm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSVMParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDTParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRandomForestParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLogisticRegressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cXGboostParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//MLAlgorithm:
		//	SVM | DT | RandomForest | LogisticRegression | XGboost;
		@Override public ParserRule getRule() { return rule; }
		
		//SVM | DT | RandomForest | LogisticRegression | XGboost
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SVM
		public RuleCall getSVMParserRuleCall_0() { return cSVMParserRuleCall_0; }
		
		//DT
		public RuleCall getDTParserRuleCall_1() { return cDTParserRuleCall_1; }
		
		//RandomForest
		public RuleCall getRandomForestParserRuleCall_2() { return cRandomForestParserRuleCall_2; }
		
		//LogisticRegression
		public RuleCall getLogisticRegressionParserRuleCall_3() { return cLogisticRegressionParserRuleCall_3; }
		
		//XGboost
		public RuleCall getXGboostParserRuleCall_4() { return cXGboostParserRuleCall_4; }
	}
	public class SVMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVM");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSVMAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSVMKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cGammaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cGammaAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cGammaFLOATParserRuleCall_2_1_0 = (RuleCall)cGammaAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cCKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cCAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cCFLOATParserRuleCall_3_1_0 = (RuleCall)cCAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Assignment cKernelSpecifiedAssignment_4_0 = (Assignment)cGroup_4.eContents().get(0);
		private final Keyword cKernelSpecifiedKernelKeyword_4_0_0 = (Keyword)cKernelSpecifiedAssignment_4_0.eContents().get(0);
		private final Assignment cKernelAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cKernelSVMKernelEnumRuleCall_4_1_0 = (RuleCall)cKernelAssignment_4_1.eContents().get(0);
		private final Group cGroup_5 = (Group)cGroup.eContents().get(5);
		private final Assignment cClassificationSpecifiedAssignment_5_0 = (Assignment)cGroup_5.eContents().get(0);
		private final Keyword cClassificationSpecifiedClassificationKeyword_5_0_0 = (Keyword)cClassificationSpecifiedAssignment_5_0.eContents().get(0);
		private final Assignment cSvmclassificationAssignment_5_1 = (Assignment)cGroup_5.eContents().get(1);
		private final RuleCall cSvmclassificationSVMClassificationEnumRuleCall_5_1_0 = (RuleCall)cSvmclassificationAssignment_5_1.eContents().get(0);
		
		//SVM:
		//	{SVM} 'SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? (kernelSpecified?='kernel=' kernel=SVMKernel)?
		//	(classificationSpecified?='classification' svmclassification=SVMClassification)?;
		@Override public ParserRule getRule() { return rule; }
		
		//{SVM} 'SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? (kernelSpecified?='kernel=' kernel=SVMKernel)?
		//(classificationSpecified?='classification' svmclassification=SVMClassification)?
		public Group getGroup() { return cGroup; }
		
		//{SVM}
		public Action getSVMAction_0() { return cSVMAction_0; }
		
		//'SVM'
		public Keyword getSVMKeyword_1() { return cSVMKeyword_1; }
		
		//('gamma=' gamma=FLOAT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'gamma='
		public Keyword getGammaKeyword_2_0() { return cGammaKeyword_2_0; }
		
		//gamma=FLOAT
		public Assignment getGammaAssignment_2_1() { return cGammaAssignment_2_1; }
		
		//FLOAT
		public RuleCall getGammaFLOATParserRuleCall_2_1_0() { return cGammaFLOATParserRuleCall_2_1_0; }
		
		//('C=' C=FLOAT)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'C='
		public Keyword getCKeyword_3_0() { return cCKeyword_3_0; }
		
		//C=FLOAT
		public Assignment getCAssignment_3_1() { return cCAssignment_3_1; }
		
		//FLOAT
		public RuleCall getCFLOATParserRuleCall_3_1_0() { return cCFLOATParserRuleCall_3_1_0; }
		
		//(kernelSpecified?='kernel=' kernel=SVMKernel)?
		public Group getGroup_4() { return cGroup_4; }
		
		//kernelSpecified?='kernel='
		public Assignment getKernelSpecifiedAssignment_4_0() { return cKernelSpecifiedAssignment_4_0; }
		
		//'kernel='
		public Keyword getKernelSpecifiedKernelKeyword_4_0_0() { return cKernelSpecifiedKernelKeyword_4_0_0; }
		
		//kernel=SVMKernel
		public Assignment getKernelAssignment_4_1() { return cKernelAssignment_4_1; }
		
		//SVMKernel
		public RuleCall getKernelSVMKernelEnumRuleCall_4_1_0() { return cKernelSVMKernelEnumRuleCall_4_1_0; }
		
		//(classificationSpecified?='classification' svmclassification=SVMClassification)?
		public Group getGroup_5() { return cGroup_5; }
		
		//classificationSpecified?='classification'
		public Assignment getClassificationSpecifiedAssignment_5_0() { return cClassificationSpecifiedAssignment_5_0; }
		
		//'classification'
		public Keyword getClassificationSpecifiedClassificationKeyword_5_0_0() { return cClassificationSpecifiedClassificationKeyword_5_0_0; }
		
		//svmclassification=SVMClassification
		public Assignment getSvmclassificationAssignment_5_1() { return cSvmclassificationAssignment_5_1; }
		
		//SVMClassification
		public RuleCall getSvmclassificationSVMClassificationEnumRuleCall_5_1_0() { return cSvmclassificationSVMClassificationEnumRuleCall_5_1_0; }
	}
	public class DTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDTAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDTKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cDecisionTreeKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Assignment cMax_depthAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cMax_depthINTTerminalRuleCall_2_0 = (RuleCall)cMax_depthAssignment_2.eContents().get(0);
		
		//DT:
		//	{DT} ('DT' | 'DecisionTree') max_depth=INT?;
		@Override public ParserRule getRule() { return rule; }
		
		//{DT} ('DT' | 'DecisionTree') max_depth=INT?
		public Group getGroup() { return cGroup; }
		
		//{DT}
		public Action getDTAction_0() { return cDTAction_0; }
		
		//('DT' | 'DecisionTree')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'DT'
		public Keyword getDTKeyword_1_0() { return cDTKeyword_1_0; }
		
		//'DecisionTree'
		public Keyword getDecisionTreeKeyword_1_1() { return cDecisionTreeKeyword_1_1; }
		
		//max_depth=INT?
		public Assignment getMax_depthAssignment_2() { return cMax_depthAssignment_2; }
		
		//INT
		public RuleCall getMax_depthINTTerminalRuleCall_2_0() { return cMax_depthINTTerminalRuleCall_2_0; }
	}
	public class RandomForestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RandomForest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cRandomForestAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cRandomForestKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cRFKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		
		//// TODO: additional hyperparameters
		//// note: R-package CART: class or anova is out of the scope since we're only targeted classification problem
		//RandomForest:
		//	{RandomForest} ('RandomForest' | 'RF');
		@Override public ParserRule getRule() { return rule; }
		
		//{RandomForest} ('RandomForest' | 'RF')
		public Group getGroup() { return cGroup; }
		
		//{RandomForest}
		public Action getRandomForestAction_0() { return cRandomForestAction_0; }
		
		//('RandomForest' | 'RF')
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'RandomForest'
		public Keyword getRandomForestKeyword_1_0() { return cRandomForestKeyword_1_0; }
		
		//'RF'
		public Keyword getRFKeyword_1_1() { return cRFKeyword_1_1; }
	}
	public class LogisticRegressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.LogisticRegression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cLogisticRegressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLogisticRegressionKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// TODO: hyperparameters?
		//LogisticRegression:
		//	{LogisticRegression}
		//	'LogisticRegression';
		@Override public ParserRule getRule() { return rule; }
		
		//{LogisticRegression} 'LogisticRegression'
		public Group getGroup() { return cGroup; }
		
		//{LogisticRegression}
		public Action getLogisticRegressionAction_0() { return cLogisticRegressionAction_0; }
		
		//'LogisticRegression'
		public Keyword getLogisticRegressionKeyword_1() { return cLogisticRegressionKeyword_1; }
	}
	public class XGboostElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.XGboost");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cXGboostAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cXGboostKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//// TODO: hyperparameters?
		//XGboost:
		//	{XGboost}
		//	'XGboost'
		//	// TODO: hyperparameters?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{XGboost} 'XGboost'
		public Group getGroup() { return cGroup; }
		
		//{XGboost}
		public Action getXGboostAction_0() { return cXGboostAction_0; }
		
		//'XGboost'
		public Keyword getXGboostKeyword_1() { return cXGboostKeyword_1; }
	}
	public class FLOATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FLOAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FLOAT:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class RFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFormulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPredictiveAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPredictiveFormulaItemParserRuleCall_1_0_0 = (RuleCall)cPredictiveAssignment_1_0.eContents().get(0);
		private final Keyword cTildeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPredictorsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredictorsXFormulaParserRuleCall_2_0 = (RuleCall)cPredictorsAssignment_2.eContents().get(0);
		
		///*
		// * mini DSL to specify "formula"
		// * inspired from R formula 
		// */ RFormula:
		//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//'formula' (predictive=FormulaItem "~")? predictors=XFormula
		public Group getGroup() { return cGroup; }
		
		//'formula'
		public Keyword getFormulaKeyword_0() { return cFormulaKeyword_0; }
		
		//(predictive=FormulaItem "~")?
		public Group getGroup_1() { return cGroup_1; }
		
		//predictive=FormulaItem
		public Assignment getPredictiveAssignment_1_0() { return cPredictiveAssignment_1_0; }
		
		//FormulaItem
		public RuleCall getPredictiveFormulaItemParserRuleCall_1_0_0() { return cPredictiveFormulaItemParserRuleCall_1_0_0; }
		
		//"~"
		public Keyword getTildeKeyword_1_1() { return cTildeKeyword_1_1; }
		
		//predictors=XFormula
		public Assignment getPredictorsAssignment_2() { return cPredictorsAssignment_2; }
		
		//XFormula
		public RuleCall getPredictorsXFormulaParserRuleCall_2_0() { return cPredictorsXFormulaParserRuleCall_2_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAllVariablesParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPredictorVariablesParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//XFormula:
		//	AllVariables | PredictorVariables;
		@Override public ParserRule getRule() { return rule; }
		
		//AllVariables | PredictorVariables
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AllVariables
		public RuleCall getAllVariablesParserRuleCall_0() { return cAllVariablesParserRuleCall_0; }
		
		//PredictorVariables
		public RuleCall getPredictorVariablesParserRuleCall_1() { return cPredictorVariablesParserRuleCall_1; }
	}
	public class AllVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.AllVariables");
		private final Assignment cAllAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cAllFullStopKeyword_0 = (Keyword)cAllAssignment.eContents().get(0);
		
		//AllVariables:
		//	all='.';
		@Override public ParserRule getRule() { return rule; }
		
		//all='.'
		public Assignment getAllAssignment() { return cAllAssignment; }
		
		//'.'
		public Keyword getAllFullStopKeyword_0() { return cAllFullStopKeyword_0; }
	}
	public class PredictorVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.PredictorVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarsFormulaItemParserRuleCall_0_0 = (RuleCall)cVarsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cVarsFormulaItemParserRuleCall_1_1_0 = (RuleCall)cVarsAssignment_1_1.eContents().get(0);
		
		//PredictorVariables:
		//	vars+=FormulaItem ("+" vars+=FormulaItem)*;
		@Override public ParserRule getRule() { return rule; }
		
		//vars+=FormulaItem ("+" vars+=FormulaItem)*
		public Group getGroup() { return cGroup; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_0() { return cVarsAssignment_0; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_0_0() { return cVarsFormulaItemParserRuleCall_0_0; }
		
		//("+" vars+=FormulaItem)*
		public Group getGroup_1() { return cGroup_1; }
		
		//"+"
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_1_1() { return cVarsAssignment_1_1; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_1_1_0() { return cVarsFormulaItemParserRuleCall_1_1_0; }
	}
	public class FormulaItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FormulaItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cColumnAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cColumnINTTerminalRuleCall_0_0 = (RuleCall)cColumnAssignment_0.eContents().get(0);
		private final Assignment cColNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cColNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cColNameAssignment_1.eContents().get(0);
		
		//// by name or integer
		//FormulaItem:
		//	column=INT | colName=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//column=INT | colName=STRING
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//column=INT
		public Assignment getColumnAssignment_0() { return cColumnAssignment_0; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_0_0() { return cColumnINTTerminalRuleCall_0_0; }
		
		//colName=STRING
		public Assignment getColNameAssignment_1() { return cColNameAssignment_1; }
		
		//STRING
		public RuleCall getColNameSTRINGTerminalRuleCall_1_0() { return cColNameSTRINGTerminalRuleCall_1_0; }
	}
	public class ValidationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.Validation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStratificationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStratificationStratificationMethodParserRuleCall_0_0 = (RuleCall)cStratificationAssignment_0.eContents().get(0);
		private final Assignment cMetricAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMetricValidationMetricEnumRuleCall_1_0 = (RuleCall)cMetricAssignment_1.eContents().get(0);
		
		///*
		// * mini DSL for evaluation
		// * choice of a "stratification" strategy and metric
		// */ Validation:
		//	stratification=StratificationMethod
		//	metric+=ValidationMetric+;
		@Override public ParserRule getRule() { return rule; }
		
		//stratification=StratificationMethod metric+=ValidationMetric+
		public Group getGroup() { return cGroup; }
		
		//stratification=StratificationMethod
		public Assignment getStratificationAssignment_0() { return cStratificationAssignment_0; }
		
		//StratificationMethod
		public RuleCall getStratificationStratificationMethodParserRuleCall_0_0() { return cStratificationStratificationMethodParserRuleCall_0_0; }
		
		//metric+=ValidationMetric+
		public Assignment getMetricAssignment_1() { return cMetricAssignment_1; }
		
		//ValidationMetric
		public RuleCall getMetricValidationMetricEnumRuleCall_1_0() { return cMetricValidationMetricEnumRuleCall_1_0; }
	}
	public class StratificationMethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.StratificationMethod");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCrossValidationParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTrainingTestParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//StratificationMethod:
		//	CrossValidation | TrainingTest;
		@Override public ParserRule getRule() { return rule; }
		
		//CrossValidation | TrainingTest
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CrossValidation
		public RuleCall getCrossValidationParserRuleCall_0() { return cCrossValidationParserRuleCall_0; }
		
		//TrainingTest
		public RuleCall getTrainingTestParserRuleCall_1() { return cTrainingTestParserRuleCall_1; }
	}
	public class CrossValidationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CrossValidation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCrossValidationKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cNumRepetitionCrossKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberINTTerminalRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//CrossValidation:
		//	'CrossValidation' '{'
		//	'numRepetitionCross' number=INT
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'CrossValidation' '{' 'numRepetitionCross' number=INT '}'
		public Group getGroup() { return cGroup; }
		
		//'CrossValidation'
		public Keyword getCrossValidationKeyword_0() { return cCrossValidationKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'numRepetitionCross'
		public Keyword getNumRepetitionCrossKeyword_2() { return cNumRepetitionCrossKeyword_2; }
		
		//number=INT
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//INT
		public RuleCall getNumberINTTerminalRuleCall_3_0() { return cNumberINTTerminalRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	public class TrainingTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.TrainingTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTrainingTestKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPercentageTrainingKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberINTTerminalRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// TODO: can certainly be extended
		//TrainingTest:
		//	'TrainingTest' '{'
		//	'percentageTraining' number=INT
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//'TrainingTest' '{' 'percentageTraining' number=INT '}'
		public Group getGroup() { return cGroup; }
		
		//'TrainingTest'
		public Keyword getTrainingTestKeyword_0() { return cTrainingTestKeyword_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'percentageTraining'
		public Keyword getPercentageTrainingKeyword_2() { return cPercentageTrainingKeyword_2; }
		
		//number=INT
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//INT
		public RuleCall getNumberINTTerminalRuleCall_3_0() { return cNumberINTTerminalRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	
	public class CSVSeparatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVSeparator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCOMMAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCOMMACommaKeyword_0_0 = (Keyword)cCOMMAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSEMI_COLONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSEMI_COLONSemicolonKeyword_1_0 = (Keyword)cSEMI_COLONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum CSVSeparator:
		//	COMMA=',' | SEMI_COLON=";";
		public EnumRule getRule() { return rule; }
		
		//COMMA=',' | SEMI_COLON=";"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//COMMA=','
		public EnumLiteralDeclaration getCOMMAEnumLiteralDeclaration_0() { return cCOMMAEnumLiteralDeclaration_0; }
		
		//','
		public Keyword getCOMMACommaKeyword_0_0() { return cCOMMACommaKeyword_0_0; }
		
		//SEMI_COLON=";"
		public EnumLiteralDeclaration getSEMI_COLONEnumLiteralDeclaration_1() { return cSEMI_COLONEnumLiteralDeclaration_1; }
		
		//";"
		public Keyword getSEMI_COLONSemicolonKeyword_1_0() { return cSEMI_COLONSemicolonKeyword_1_0; }
	}
	public class FrameworkLangElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FrameworkLang");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSCIKITEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSCIKITScikitLearnKeyword_0_0 = (Keyword)cSCIKITEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRRKeyword_1_0 = (Keyword)cREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cJavaWekaEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cJavaWekaWekaKeyword_2_0 = (Keyword)cJavaWekaEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum FrameworkLang:
		//	SCIKIT="scikit-learn" | R | JavaWeka="Weka";
		public EnumRule getRule() { return rule; }
		
		//SCIKIT="scikit-learn" | R | JavaWeka="Weka"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SCIKIT="scikit-learn"
		public EnumLiteralDeclaration getSCIKITEnumLiteralDeclaration_0() { return cSCIKITEnumLiteralDeclaration_0; }
		
		//"scikit-learn"
		public Keyword getSCIKITScikitLearnKeyword_0_0() { return cSCIKITScikitLearnKeyword_0_0; }
		
		//R
		public EnumLiteralDeclaration getREnumLiteralDeclaration_1() { return cREnumLiteralDeclaration_1; }
		
		//"R"
		public Keyword getRRKeyword_1_0() { return cRRKeyword_1_0; }
		
		//JavaWeka="Weka"
		public EnumLiteralDeclaration getJavaWekaEnumLiteralDeclaration_2() { return cJavaWekaEnumLiteralDeclaration_2; }
		
		//"Weka"
		public Keyword getJavaWekaWekaKeyword_2_0() { return cJavaWekaWekaKeyword_2_0; }
	}
	public class SVMKernelElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVMKernel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLinearEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLinearLinearKeyword_0_0 = (Keyword)cLinearEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPolyEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPolyPolynomialKeyword_1_0 = (Keyword)cPolyEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cRadialEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cRadialRadialKeyword_2_0 = (Keyword)cRadialEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum SVMKernel:
		//	linear | poly='polynomial' | radial;
		public EnumRule getRule() { return rule; }
		
		//linear | poly='polynomial' | radial
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//linear
		public EnumLiteralDeclaration getLinearEnumLiteralDeclaration_0() { return cLinearEnumLiteralDeclaration_0; }
		
		//'linear'
		public Keyword getLinearLinearKeyword_0_0() { return cLinearLinearKeyword_0_0; }
		
		//poly='polynomial'
		public EnumLiteralDeclaration getPolyEnumLiteralDeclaration_1() { return cPolyEnumLiteralDeclaration_1; }
		
		//'polynomial'
		public Keyword getPolyPolynomialKeyword_1_0() { return cPolyPolynomialKeyword_1_0; }
		
		//radial
		public EnumLiteralDeclaration getRadialEnumLiteralDeclaration_2() { return cRadialEnumLiteralDeclaration_2; }
		
		//'radial'
		public Keyword getRadialRadialKeyword_2_0() { return cRadialRadialKeyword_2_0; }
	}
	public class SVMClassificationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVMClassification");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCClassEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCClassCClassificationKeyword_0_0 = (Keyword)cCClassEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNuClassEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNuClassNuClassificationKeyword_1_0 = (Keyword)cNuClassEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOneClassEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOneClassOneClassificationKeyword_2_0 = (Keyword)cOneClassEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum SVMClassification:
		//	cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification";
		public EnumRule getRule() { return rule; }
		
		//cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//cClass="C-classification"
		public EnumLiteralDeclaration getCClassEnumLiteralDeclaration_0() { return cCClassEnumLiteralDeclaration_0; }
		
		//"C-classification"
		public Keyword getCClassCClassificationKeyword_0_0() { return cCClassCClassificationKeyword_0_0; }
		
		//nuClass="nu-classification"
		public EnumLiteralDeclaration getNuClassEnumLiteralDeclaration_1() { return cNuClassEnumLiteralDeclaration_1; }
		
		//"nu-classification"
		public Keyword getNuClassNuClassificationKeyword_1_0() { return cNuClassNuClassificationKeyword_1_0; }
		
		//oneClass="one-classification"
		public EnumLiteralDeclaration getOneClassEnumLiteralDeclaration_2() { return cOneClassEnumLiteralDeclaration_2; }
		
		//"one-classification"
		public Keyword getOneClassOneClassificationKeyword_2_0() { return cOneClassOneClassificationKeyword_2_0; }
	}
	public class ValidationMetricElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.ValidationMetric");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBALANCED_ACCURACYEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBALANCED_ACCURACYBalanced_accuracyKeyword_0_0 = (Keyword)cBALANCED_ACCURACYEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cRECALLEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRECALLRecallKeyword_1_0 = (Keyword)cRECALLEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPRECISIONEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPRECISIONPrecisionKeyword_2_0 = (Keyword)cPRECISIONEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cF1EnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cF1F1Keyword_3_0 = (Keyword)cF1EnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cACCURACYEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cACCURACYAccuracyKeyword_4_0 = (Keyword)cACCURACYEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cMACRO_RECALLEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cMACRO_RECALLMacro_recallKeyword_5_0 = (Keyword)cMACRO_RECALLEnumLiteralDeclaration_5.eContents().get(0);
		private final EnumLiteralDeclaration cMACRO_PRECISIONEnumLiteralDeclaration_6 = (EnumLiteralDeclaration)cAlternatives.eContents().get(6);
		private final Keyword cMACRO_PRECISIONMacro_precisionKeyword_6_0 = (Keyword)cMACRO_PRECISIONEnumLiteralDeclaration_6.eContents().get(0);
		private final EnumLiteralDeclaration cMACRO_F1EnumLiteralDeclaration_7 = (EnumLiteralDeclaration)cAlternatives.eContents().get(7);
		private final Keyword cMACRO_F1Macro_F1Keyword_7_0 = (Keyword)cMACRO_F1EnumLiteralDeclaration_7.eContents().get(0);
		private final EnumLiteralDeclaration cMACRO_ACCURACYEnumLiteralDeclaration_8 = (EnumLiteralDeclaration)cAlternatives.eContents().get(8);
		private final Keyword cMACRO_ACCURACYMacro_accuracyKeyword_8_0 = (Keyword)cMACRO_ACCURACYEnumLiteralDeclaration_8.eContents().get(0);
		
		//enum ValidationMetric:
		//	BALANCED_ACCURACY='balanced_accuracy' | RECALL='recall' | PRECISION='precision' | F1 | ACCURACY='accuracy' |
		//	MACRO_RECALL='macro_recall' | MACRO_PRECISION='macro_precision' | MACRO_F1='macro_F1' |
		//	MACRO_ACCURACY='macro_accuracy';
		public EnumRule getRule() { return rule; }
		
		//BALANCED_ACCURACY='balanced_accuracy' | RECALL='recall' | PRECISION='precision' | F1 | ACCURACY='accuracy' |
		//MACRO_RECALL='macro_recall' | MACRO_PRECISION='macro_precision' | MACRO_F1='macro_F1' | MACRO_ACCURACY='macro_accuracy'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BALANCED_ACCURACY='balanced_accuracy'
		public EnumLiteralDeclaration getBALANCED_ACCURACYEnumLiteralDeclaration_0() { return cBALANCED_ACCURACYEnumLiteralDeclaration_0; }
		
		//'balanced_accuracy'
		public Keyword getBALANCED_ACCURACYBalanced_accuracyKeyword_0_0() { return cBALANCED_ACCURACYBalanced_accuracyKeyword_0_0; }
		
		//RECALL='recall'
		public EnumLiteralDeclaration getRECALLEnumLiteralDeclaration_1() { return cRECALLEnumLiteralDeclaration_1; }
		
		//'recall'
		public Keyword getRECALLRecallKeyword_1_0() { return cRECALLRecallKeyword_1_0; }
		
		//PRECISION='precision'
		public EnumLiteralDeclaration getPRECISIONEnumLiteralDeclaration_2() { return cPRECISIONEnumLiteralDeclaration_2; }
		
		//'precision'
		public Keyword getPRECISIONPrecisionKeyword_2_0() { return cPRECISIONPrecisionKeyword_2_0; }
		
		//F1
		public EnumLiteralDeclaration getF1EnumLiteralDeclaration_3() { return cF1EnumLiteralDeclaration_3; }
		
		//'F1'
		public Keyword getF1F1Keyword_3_0() { return cF1F1Keyword_3_0; }
		
		//ACCURACY='accuracy'
		public EnumLiteralDeclaration getACCURACYEnumLiteralDeclaration_4() { return cACCURACYEnumLiteralDeclaration_4; }
		
		//'accuracy'
		public Keyword getACCURACYAccuracyKeyword_4_0() { return cACCURACYAccuracyKeyword_4_0; }
		
		//MACRO_RECALL='macro_recall'
		public EnumLiteralDeclaration getMACRO_RECALLEnumLiteralDeclaration_5() { return cMACRO_RECALLEnumLiteralDeclaration_5; }
		
		//'macro_recall'
		public Keyword getMACRO_RECALLMacro_recallKeyword_5_0() { return cMACRO_RECALLMacro_recallKeyword_5_0; }
		
		//MACRO_PRECISION='macro_precision'
		public EnumLiteralDeclaration getMACRO_PRECISIONEnumLiteralDeclaration_6() { return cMACRO_PRECISIONEnumLiteralDeclaration_6; }
		
		//'macro_precision'
		public Keyword getMACRO_PRECISIONMacro_precisionKeyword_6_0() { return cMACRO_PRECISIONMacro_precisionKeyword_6_0; }
		
		//MACRO_F1='macro_F1'
		public EnumLiteralDeclaration getMACRO_F1EnumLiteralDeclaration_7() { return cMACRO_F1EnumLiteralDeclaration_7; }
		
		//'macro_F1'
		public Keyword getMACRO_F1Macro_F1Keyword_7_0() { return cMACRO_F1Macro_F1Keyword_7_0; }
		
		//MACRO_ACCURACY='macro_accuracy'
		public EnumLiteralDeclaration getMACRO_ACCURACYEnumLiteralDeclaration_8() { return cMACRO_ACCURACYEnumLiteralDeclaration_8; }
		
		//'macro_accuracy'
		public Keyword getMACRO_ACCURACYMacro_accuracyKeyword_8_0() { return cMACRO_ACCURACYMacro_accuracyKeyword_8_0; }
	}
	
	private final MMLModelElements pMMLModel;
	private final DataInputElements pDataInput;
	private final CSVParsingConfigurationElements pCSVParsingConfiguration;
	private final CSVSeparatorElements eCSVSeparator;
	private final MLChoiceAlgorithmElements pMLChoiceAlgorithm;
	private final FrameworkLangElements eFrameworkLang;
	private final MLAlgorithmElements pMLAlgorithm;
	private final SVMElements pSVM;
	private final SVMKernelElements eSVMKernel;
	private final SVMClassificationElements eSVMClassification;
	private final DTElements pDT;
	private final RandomForestElements pRandomForest;
	private final LogisticRegressionElements pLogisticRegression;
	private final XGboostElements pXGboost;
	private final FLOATElements pFLOAT;
	private final RFormulaElements pRFormula;
	private final XFormulaElements pXFormula;
	private final AllVariablesElements pAllVariables;
	private final PredictorVariablesElements pPredictorVariables;
	private final FormulaItemElements pFormulaItem;
	private final ValidationElements pValidation;
	private final StratificationMethodElements pStratificationMethod;
	private final CrossValidationElements pCrossValidation;
	private final TrainingTestElements pTrainingTest;
	private final ValidationMetricElements eValidationMetric;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MmlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMMLModel = new MMLModelElements();
		this.pDataInput = new DataInputElements();
		this.pCSVParsingConfiguration = new CSVParsingConfigurationElements();
		this.eCSVSeparator = new CSVSeparatorElements();
		this.pMLChoiceAlgorithm = new MLChoiceAlgorithmElements();
		this.eFrameworkLang = new FrameworkLangElements();
		this.pMLAlgorithm = new MLAlgorithmElements();
		this.pSVM = new SVMElements();
		this.eSVMKernel = new SVMKernelElements();
		this.eSVMClassification = new SVMClassificationElements();
		this.pDT = new DTElements();
		this.pRandomForest = new RandomForestElements();
		this.pLogisticRegression = new LogisticRegressionElements();
		this.pXGboost = new XGboostElements();
		this.pFLOAT = new FLOATElements();
		this.pRFormula = new RFormulaElements();
		this.pXFormula = new XFormulaElements();
		this.pAllVariables = new AllVariablesElements();
		this.pPredictorVariables = new PredictorVariablesElements();
		this.pFormulaItem = new FormulaItemElements();
		this.pValidation = new ValidationElements();
		this.pStratificationMethod = new StratificationMethodElements();
		this.pCrossValidation = new CrossValidationElements();
		this.pTrainingTest = new TrainingTestElements();
		this.eValidationMetric = new ValidationMetricElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.Mml".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//MMLModel:
	//	input=DataInput
	//	algorithms+=MLChoiceAlgorithm+
	//	formula=RFormula?
	//	validation=Validation;
	public MMLModelElements getMMLModelAccess() {
		return pMMLModel;
	}
	
	public ParserRule getMMLModelRule() {
		return getMMLModelAccess().getRule();
	}
	
	///*
	// * 
	// * mini DSL to read data (here CSV)
	// * mini CSV DSL
	// */ DataInput:
	//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
	public DataInputElements getDataInputAccess() {
		return pDataInput;
	}
	
	public ParserRule getDataInputRule() {
		return getDataInputAccess().getRule();
	}
	
	//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
	//	"separator" sep=CSVSeparator;
	public CSVParsingConfigurationElements getCSVParsingConfigurationAccess() {
		return pCSVParsingConfiguration;
	}
	
	public ParserRule getCSVParsingConfigurationRule() {
		return getCSVParsingConfigurationAccess().getRule();
	}
	
	//enum CSVSeparator:
	//	COMMA=',' | SEMI_COLON=";";
	public CSVSeparatorElements getCSVSeparatorAccess() {
		return eCSVSeparator;
	}
	
	public EnumRule getCSVSeparatorRule() {
		return getCSVSeparatorAccess().getRule();
	}
	
	///*
	// * mini DSL to select the ML algorithm we want 
	// * we include the choice of the targeted language/framework
	// * ML algorithms can have hyperparameters
	// * 
	// */ MLChoiceAlgorithm:
	//	'mlframework' framework=FrameworkLang
	//	'algorithm' algorithm=MLAlgorithm;
	public MLChoiceAlgorithmElements getMLChoiceAlgorithmAccess() {
		return pMLChoiceAlgorithm;
	}
	
	public ParserRule getMLChoiceAlgorithmRule() {
		return getMLChoiceAlgorithmAccess().getRule();
	}
	
	//enum FrameworkLang:
	//	SCIKIT="scikit-learn" | R | JavaWeka="Weka";
	public FrameworkLangElements getFrameworkLangAccess() {
		return eFrameworkLang;
	}
	
	public EnumRule getFrameworkLangRule() {
		return getFrameworkLangAccess().getRule();
	}
	
	//MLAlgorithm:
	//	SVM | DT | RandomForest | LogisticRegression | XGboost;
	public MLAlgorithmElements getMLAlgorithmAccess() {
		return pMLAlgorithm;
	}
	
	public ParserRule getMLAlgorithmRule() {
		return getMLAlgorithmAccess().getRule();
	}
	
	//SVM:
	//	{SVM} 'SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? (kernelSpecified?='kernel=' kernel=SVMKernel)?
	//	(classificationSpecified?='classification' svmclassification=SVMClassification)?;
	public SVMElements getSVMAccess() {
		return pSVM;
	}
	
	public ParserRule getSVMRule() {
		return getSVMAccess().getRule();
	}
	
	//enum SVMKernel:
	//	linear | poly='polynomial' | radial;
	public SVMKernelElements getSVMKernelAccess() {
		return eSVMKernel;
	}
	
	public EnumRule getSVMKernelRule() {
		return getSVMKernelAccess().getRule();
	}
	
	//enum SVMClassification:
	//	cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification";
	public SVMClassificationElements getSVMClassificationAccess() {
		return eSVMClassification;
	}
	
	public EnumRule getSVMClassificationRule() {
		return getSVMClassificationAccess().getRule();
	}
	
	//DT:
	//	{DT} ('DT' | 'DecisionTree') max_depth=INT?;
	public DTElements getDTAccess() {
		return pDT;
	}
	
	public ParserRule getDTRule() {
		return getDTAccess().getRule();
	}
	
	//// TODO: additional hyperparameters
	//// note: R-package CART: class or anova is out of the scope since we're only targeted classification problem
	//RandomForest:
	//	{RandomForest} ('RandomForest' | 'RF');
	public RandomForestElements getRandomForestAccess() {
		return pRandomForest;
	}
	
	public ParserRule getRandomForestRule() {
		return getRandomForestAccess().getRule();
	}
	
	//// TODO: hyperparameters?
	//LogisticRegression:
	//	{LogisticRegression}
	//	'LogisticRegression';
	public LogisticRegressionElements getLogisticRegressionAccess() {
		return pLogisticRegression;
	}
	
	public ParserRule getLogisticRegressionRule() {
		return getLogisticRegressionAccess().getRule();
	}
	
	//// TODO: hyperparameters?
	//XGboost:
	//	{XGboost}
	//	'XGboost'
	//	// TODO: hyperparameters?
	//;
	public XGboostElements getXGboostAccess() {
		return pXGboost;
	}
	
	public ParserRule getXGboostRule() {
		return getXGboostAccess().getRule();
	}
	
	//FLOAT:
	//	INT '.' INT;
	public FLOATElements getFLOATAccess() {
		return pFLOAT;
	}
	
	public ParserRule getFLOATRule() {
		return getFLOATAccess().getRule();
	}
	
	///*
	// * mini DSL to specify "formula"
	// * inspired from R formula 
	// */ RFormula:
	//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
	public RFormulaElements getRFormulaAccess() {
		return pRFormula;
	}
	
	public ParserRule getRFormulaRule() {
		return getRFormulaAccess().getRule();
	}
	
	//XFormula:
	//	AllVariables | PredictorVariables;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//AllVariables:
	//	all='.';
	public AllVariablesElements getAllVariablesAccess() {
		return pAllVariables;
	}
	
	public ParserRule getAllVariablesRule() {
		return getAllVariablesAccess().getRule();
	}
	
	//PredictorVariables:
	//	vars+=FormulaItem ("+" vars+=FormulaItem)*;
	public PredictorVariablesElements getPredictorVariablesAccess() {
		return pPredictorVariables;
	}
	
	public ParserRule getPredictorVariablesRule() {
		return getPredictorVariablesAccess().getRule();
	}
	
	//// by name or integer
	//FormulaItem:
	//	column=INT | colName=STRING;
	public FormulaItemElements getFormulaItemAccess() {
		return pFormulaItem;
	}
	
	public ParserRule getFormulaItemRule() {
		return getFormulaItemAccess().getRule();
	}
	
	///*
	// * mini DSL for evaluation
	// * choice of a "stratification" strategy and metric
	// */ Validation:
	//	stratification=StratificationMethod
	//	metric+=ValidationMetric+;
	public ValidationElements getValidationAccess() {
		return pValidation;
	}
	
	public ParserRule getValidationRule() {
		return getValidationAccess().getRule();
	}
	
	//StratificationMethod:
	//	CrossValidation | TrainingTest;
	public StratificationMethodElements getStratificationMethodAccess() {
		return pStratificationMethod;
	}
	
	public ParserRule getStratificationMethodRule() {
		return getStratificationMethodAccess().getRule();
	}
	
	//CrossValidation:
	//	'CrossValidation' '{'
	//	'numRepetitionCross' number=INT
	//	'}';
	public CrossValidationElements getCrossValidationAccess() {
		return pCrossValidation;
	}
	
	public ParserRule getCrossValidationRule() {
		return getCrossValidationAccess().getRule();
	}
	
	//// TODO: can certainly be extended
	//TrainingTest:
	//	'TrainingTest' '{'
	//	'percentageTraining' number=INT
	//	'}';
	public TrainingTestElements getTrainingTestAccess() {
		return pTrainingTest;
	}
	
	public ParserRule getTrainingTestRule() {
		return getTrainingTestAccess().getRule();
	}
	
	//enum ValidationMetric:
	//	BALANCED_ACCURACY='balanced_accuracy' | RECALL='recall' | PRECISION='precision' | F1 | ACCURACY='accuracy' |
	//	MACRO_RECALL='macro_recall' | MACRO_PRECISION='macro_precision' | MACRO_F1='macro_F1' |
	//	MACRO_ACCURACY='macro_accuracy';
	public ValidationMetricElements getValidationMetricAccess() {
		return eValidationMetric;
	}
	
	public EnumRule getValidationMetricRule() {
		return getValidationMetricAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
