/*
 * generated by Xtext 2.20.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.mml.AllVariables;
import org.xtext.example.mydsl.mml.CSVParsingConfiguration;
import org.xtext.example.mydsl.mml.CrossValidation;
import org.xtext.example.mydsl.mml.DT;
import org.xtext.example.mydsl.mml.DataInput;
import org.xtext.example.mydsl.mml.FormulaItem;
import org.xtext.example.mydsl.mml.LogisticRegression;
import org.xtext.example.mydsl.mml.MLChoiceAlgorithm;
import org.xtext.example.mydsl.mml.MMLModel;
import org.xtext.example.mydsl.mml.MmlPackage;
import org.xtext.example.mydsl.mml.PredictorVariables;
import org.xtext.example.mydsl.mml.RFormula;
import org.xtext.example.mydsl.mml.RandomForest;
import org.xtext.example.mydsl.mml.SVM;
import org.xtext.example.mydsl.mml.TrainingTest;
import org.xtext.example.mydsl.mml.Validation;
import org.xtext.example.mydsl.mml.XGboost;
import org.xtext.example.mydsl.services.MmlGrammarAccess;

@SuppressWarnings("all")
public class MmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MmlPackage.ALL_VARIABLES:
				sequence_AllVariables(context, (AllVariables) semanticObject); 
				return; 
			case MmlPackage.CSV_PARSING_CONFIGURATION:
				sequence_CSVParsingConfiguration(context, (CSVParsingConfiguration) semanticObject); 
				return; 
			case MmlPackage.CROSS_VALIDATION:
				sequence_CrossValidation(context, (CrossValidation) semanticObject); 
				return; 
			case MmlPackage.DT:
				sequence_DT(context, (DT) semanticObject); 
				return; 
			case MmlPackage.DATA_INPUT:
				sequence_DataInput(context, (DataInput) semanticObject); 
				return; 
			case MmlPackage.FORMULA_ITEM:
				sequence_FormulaItem(context, (FormulaItem) semanticObject); 
				return; 
			case MmlPackage.LOGISTIC_REGRESSION:
				sequence_LogisticRegression(context, (LogisticRegression) semanticObject); 
				return; 
			case MmlPackage.ML_CHOICE_ALGORITHM:
				sequence_MLChoiceAlgorithm(context, (MLChoiceAlgorithm) semanticObject); 
				return; 
			case MmlPackage.MML_MODEL:
				sequence_MMLModel(context, (MMLModel) semanticObject); 
				return; 
			case MmlPackage.PREDICTOR_VARIABLES:
				sequence_PredictorVariables(context, (PredictorVariables) semanticObject); 
				return; 
			case MmlPackage.RFORMULA:
				sequence_RFormula(context, (RFormula) semanticObject); 
				return; 
			case MmlPackage.RANDOM_FOREST:
				sequence_RandomForest(context, (RandomForest) semanticObject); 
				return; 
			case MmlPackage.SVM:
				sequence_SVM(context, (SVM) semanticObject); 
				return; 
			case MmlPackage.TRAINING_TEST:
				sequence_TrainingTest(context, (TrainingTest) semanticObject); 
				return; 
			case MmlPackage.VALIDATION:
				sequence_Validation(context, (Validation) semanticObject); 
				return; 
			case MmlPackage.XGBOOST:
				sequence_XGboost(context, (XGboost) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     XFormula returns AllVariables
	 *     AllVariables returns AllVariables
	 *
	 * Constraint:
	 *     all='.'
	 */
	protected void sequence_AllVariables(ISerializationContext context, AllVariables semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ALL_VARIABLES__ALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ALL_VARIABLES__ALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllVariablesAccess().getAllFullStopKeyword_0(), semanticObject.getAll());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSVParsingConfiguration returns CSVParsingConfiguration
	 *
	 * Constraint:
	 *     sep=CSVSeparator
	 */
	protected void sequence_CSVParsingConfiguration(ISerializationContext context, CSVParsingConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.CSV_PARSING_CONFIGURATION__SEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.CSV_PARSING_CONFIGURATION__SEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCSVParsingConfigurationAccess().getSepCSVSeparatorEnumRuleCall_1_0(), semanticObject.getSep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StratificationMethod returns CrossValidation
	 *     CrossValidation returns CrossValidation
	 *
	 * Constraint:
	 *     number=INT
	 */
	protected void sequence_CrossValidation(ISerializationContext context, CrossValidation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.STRATIFICATION_METHOD__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.STRATIFICATION_METHOD__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCrossValidationAccess().getNumberINTTerminalRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns DT
	 *     DT returns DT
	 *
	 * Constraint:
	 *     max_depth=INT?
	 */
	protected void sequence_DT(ISerializationContext context, DT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataInput returns DataInput
	 *
	 * Constraint:
	 *     (filelocation=STRING parsingInstruction=CSVParsingConfiguration?)
	 */
	protected void sequence_DataInput(ISerializationContext context, DataInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormulaItem returns FormulaItem
	 *
	 * Constraint:
	 *     (column=INT | colName=STRING)
	 */
	protected void sequence_FormulaItem(ISerializationContext context, FormulaItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns LogisticRegression
	 *     LogisticRegression returns LogisticRegression
	 *
	 * Constraint:
	 *     {LogisticRegression}
	 */
	protected void sequence_LogisticRegression(ISerializationContext context, LogisticRegression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLChoiceAlgorithm returns MLChoiceAlgorithm
	 *
	 * Constraint:
	 *     (framework=FrameworkLang algorithm=MLAlgorithm)
	 */
	protected void sequence_MLChoiceAlgorithm(ISerializationContext context, MLChoiceAlgorithm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__FRAMEWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__FRAMEWORK));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__ALGORITHM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__ALGORITHM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMLChoiceAlgorithmAccess().getFrameworkFrameworkLangEnumRuleCall_1_0(), semanticObject.getFramework());
		feeder.accept(grammarAccess.getMLChoiceAlgorithmAccess().getAlgorithmMLAlgorithmParserRuleCall_3_0(), semanticObject.getAlgorithm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MMLModel returns MMLModel
	 *
	 * Constraint:
	 *     (input=DataInput algorithms+=MLChoiceAlgorithm+ formula=RFormula? validation=Validation)
	 */
	protected void sequence_MMLModel(ISerializationContext context, MMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XFormula returns PredictorVariables
	 *     PredictorVariables returns PredictorVariables
	 *
	 * Constraint:
	 *     (vars+=FormulaItem vars+=FormulaItem*)
	 */
	protected void sequence_PredictorVariables(ISerializationContext context, PredictorVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RFormula returns RFormula
	 *
	 * Constraint:
	 *     (predictive=FormulaItem? predictors=XFormula)
	 */
	protected void sequence_RFormula(ISerializationContext context, RFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns RandomForest
	 *     RandomForest returns RandomForest
	 *
	 * Constraint:
	 *     {RandomForest}
	 */
	protected void sequence_RandomForest(ISerializationContext context, RandomForest semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns SVM
	 *     SVM returns SVM
	 *
	 * Constraint:
	 *     (
	 *         gamma=FLOAT? 
	 *         C=FLOAT? 
	 *         (kernelSpecified?='kernel=' kernel=SVMKernel)? 
	 *         (classificationSpecified?='classification' svmclassification=SVMClassification)?
	 *     )
	 */
	protected void sequence_SVM(ISerializationContext context, SVM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StratificationMethod returns TrainingTest
	 *     TrainingTest returns TrainingTest
	 *
	 * Constraint:
	 *     number=INT
	 */
	protected void sequence_TrainingTest(ISerializationContext context, TrainingTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.STRATIFICATION_METHOD__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.STRATIFICATION_METHOD__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrainingTestAccess().getNumberINTTerminalRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Validation returns Validation
	 *
	 * Constraint:
	 *     (stratification=StratificationMethod metric+=ValidationMetric+)
	 */
	protected void sequence_Validation(ISerializationContext context, Validation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns XGboost
	 *     XGboost returns XGboost
	 *
	 * Constraint:
	 *     {XGboost}
	 */
	protected void sequence_XGboost(ISerializationContext context, XGboost semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
